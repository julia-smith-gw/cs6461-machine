
    public int encodeInstruction(String instruction, OpcodeTable opcodeTable, SymbolTable labels) throws Exception {
        String[] instructionParts = instruction.trim().split("\\s+", 2);
        String label = InstructionStringUtil.extractLabel(instructionParts);
        String op = InstructionStringUtil.extractOp(instructionParts, label);
        int argStartIndex = label != null ? 2 : 1;
        String[] args = InstructionStringUtil.extractArgs(instructionParts, argStartIndex);

        // throw error if operation is not found
        OpcodeInfo opcodeInfo = opcodeTable.lookup(op);
        if (opcodeInfo == null) {
            throw new NoSuchElementException("Op code not recognized at line");
        }

        BitConfigurationType bitCodeConfig = opcodeInfo.bitConfiguration();
        int result = 0;
        result |= (opcodeInfo.getOpcode() & 0x3F) << 10; // opcode is top 6 bits of 16-bit word

        switch (bitCodeConfig) {
            case ARITH_LOGIC_MEM:
            case TRANSFER:
            case LOAD_STORE: {
                // expect forms like: <mnemonic> r, x, address[,I]
                // r: 0-3
                // x: 0-3 (with 0 meaning no indexing; 1-3 represent IX1-IX3)
                // address: decimal or label
                // optional ",I" indicates I=1 else I=0
                // Fields (bits): [ opcode:6 ] [ R:2 ] [ IX:2 ] [ I:1 ] [ Address:5 ] = total 16
                // bits (6+2+2+1+5 = 16) :contentReference[oaicite:4]{index=4}

                if (args.length != 3 && args.length != 4) {
                    throw new IllegalArgumentException(
                            "Wrong operand count for " + op + ". Operands should be 3 or 4)");
                }

                // operand 0: R register
                int register = parseRegister(args[0]);
                int indexRegister = parseIndexRegister(args[1]);
                int destinationAddress = parseAddressOrLabel(args[2], indexRegister, labels);
                int indirectAddressingFlag = parseIndirectAddressingFlag(args[3]);

                result |= (register & 0x3) << 8 | (indexRegister & 0x3) << 6 | (indirectAddressingFlag & 0x1) << 5
                        | (destinationAddress & 0x1F);
                return result;

            }
            case LOAD_STORE_IR: {
                if (args.length != 2 && args.length != 3) {
                    throw new IllegalArgumentException(
                            "Wrong operand count for " + op + ". Operands should be 2 or 3)");
                }

                // operand 0: R register
                int indexRegister = parseIndexRegister(args[0]);
                int destinationAddress = parseAddressOrLabel(args[1], indexRegister, labels);
                int indirectAddressingFlag = parseIndirectAddressingFlag(args[2]);

            result |= (indexRegister & 0x3) << 8 |(indirectAddressingFlag & 0x1) << 5 | (destinationAddress & 0x1F)  ;  // in LDX/STX, IX field shifted left
                return result;
            }
            case IMMEDIATE: {
                // e.g., AIR r, immed or SIR r, immed
                // Format: opcode:6, R:2, immediate:5 (unsigned? signed?), other bits ignored /
                // zero.
                if (args.length != 2) {
                    throw new IllegalArgumentException("Wrong operand count for " + op + ". Operands should be 2.");
                }

                int register = parseRegister(args[0]);
                int immed = parseDecimal(args[1]);
                // immediate allowed range is -31 to +31? (5 bits signed) per spec for immediate
                // arithmetic ops. :contentReference[oaicite:5]{index=5}
                if (immed < -31 || immed > 31) {
                    throw new IllegalArgumentException("Immediate out of range for " + op + ": " + immed);
                }
                // Signed immediate mapped into a 5-bit two's complement field
                result |= (register & 0x3) << 8 | (immed & 0x1F);
                return result;
            }
            case ARITH_LOGIC_REG:
                // e.g. AND r1, r2 or NOT r1 (one operand)
                // Often these use a different format: maybe opcode (6), reg fields, etc.

                // Simplified version: format: opcode:6, Rdest:2, Rsource:2, rest zero
                // E.g., "AND r1, r2" means r1 = r1 & r2
                if (args.length != 2) {
                    throw new IllegalArgumentException("Wrong operand count for " + op + ". Operands should be 2.");
                }
                int rd = parseRegister(args[0]);
                int rs = parseRegister(args[1]);
                result |= (rd & 0x3) << 8 | (rs & 0x3) << 6;
                return result;

            case SHIFT_ROTATE: {
                // e.g. SRC r, count, L/R, A/L
                if (args.length != 4) {
                    throw new IllegalArgumentException("Wrong operand count for " + op + ". Operands should be 4");
                }
                int rsh = parseRegister(args[0]);
                int count = parseDecimal(args[1]);
                if (count < 0 || count > 15) {
                    throw new IllegalArgumentException("Shift count out of range (0-15): " + count);
                }
                String lr = args[2].toUpperCase();
                String al = args[3].toUpperCase();
                int bitLR = 0;
                int bitAL = 0;
                if (lr.equals("L"))
                    bitLR = 1;
                else if (lr.equals("R"))
                    bitLR = 0;
                else
                    throw new IllegalArgumentException("Third operand must be L or R");
                if (al.equals("A"))
                    bitAL = 0; // arithmetic
                else if (al.equals("L"))
                    bitAL = 1; // logical
                else
                    throw new IllegalArgumentException("Fourth operand must be A or L");

                result |= (rsh & 0x3) << 8 | (count & 0xF) << 4 | (bitLR & 0x1) << 3 | (bitAL & 0x1) << 2;
                return result;
            }
            case MISC:
                if (op.equals("HLT")) {
                    // HLT is opcode 0, rest bits zero
                    return result;
                }
                // other miscellaneous instructions like TRAP etc.
                throw new UnsupportedOperationException("Misc instruction not implemented: " + def.name);
            default:
                throw new UnsupportedOperationException("Unsupported instruction/ unknown error on: " + op);
        }
    }