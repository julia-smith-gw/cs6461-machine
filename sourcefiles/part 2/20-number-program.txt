LOC 6
zero: DATA 0
LDA 0,0,zero       ; R0 = 0300 (octal)
AIR 0,3            ; R0 = 3
SRC 0,6,L,L        ; shift left 6 (LR=1 for left, AL=0 for logical) → R0 = 0300
STR 0,0,20         ; [0020] = 0300 (safe cell far from buffer)
LDX 1,20           ; X1 = [0020] = 0300  (touches M[0300] before IN)
LDR 3,1,0          ; R3 <- M[X1] (sets MAR=0300; good if IN uses MAR)
LDA 3,0,zero       ; R3 = 0
LDR 3,0,zero       ; R3 ← M[zero] = 0   (since zero: DATA 0)
AIR 3,20           ; R3 = 20
OUT 0,1            ; guidance for 20 numbers (see AIR and LDA above)
IN  0,0            ; store 20 ints at M[R0] .. M[R0+19]
LDX 1,20           ; re-seed X1 = [0020] = 0300
LDR 0,0,20         ; R0 = [0020] = 0300 (defensive)
STR 0,0,20         ; keep [0020] = 0300
LDX 1,20           ; X1 = 0300
LDA 2,0,20         ; R2 = 20
LDR 3,1,0          ; print loop: R3 = M[X1]
OUT 3,3
STX 1,20           ; [0020] = X1
LDR 0,0,20         ; R0 = [0020]
AIR 0,1            ; R0++
STR 0,0,20         ; [0020] = R0
LDX 1,20           ; X1 = [0020]
SOB 2,0,23
LDR 3,0,zero       ; R3 = 0   (clear count)
AIR 3,1            ; R3 = 1   (only one number this time)
LDR 0,0,20         ; R0 = [0020] = 0300
AIR 0,20           ; R0 = 0300 + 20 = 0324 (next free 20-slot window)
STR 0,0,21        ; save base at [0021] BEFORE IN clobbers R0
OUT 0,1         ; ask for one number
IN  0,0         ; reads 1 number into M[R0]
LDX 1,21        ; X1 = saved base
LDR 3,1,0       ; R3 = M[X1] -> the single number
OUT 3,3
HLT
