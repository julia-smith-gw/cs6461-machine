              LOC 6                   ; assistance provided by https://chatgpt.com/share/69070339-7280-8007-96f4-d8609fd04133
              AIR 2,1                 ; R2 = 1
              SRC 2,6,L,L             ; R2 = 0o0100
              AIR 2,24                ; +24(dec) = +0o30  => R2 = 0o0130
              STR 2,0,22
              LDX 2,22                ; IX2 = 0o0130
              LDR 0,2,11             ; R0 := M[X2+11] = ZERO = 0
              AIR 0,3                ; R0 := 0003₈
              SRC 0,6,L,L            ; R0 := 0300₈
              STR 0,0,20             ; [0020] = 0300₈
              LDX 1,20               ; IX1 := 0300₈
              LDR 0,0,20
              STR 0,0,23
              LDR 1,2,11
              AIR 1,20
              OUT 0,1
              IN 0,0
              LDX 1,20
              LDR 0,0,20
              STR 0,0,23
              LDR 1,2,11
              AIR 1,20
PLOOP:        LDX 1,23
              LDR 3,1,0
              OUT 3,3
              LDR 0,0,23
              AIR 0,1
              STR 0,0,23
              SOB 1,0,PLOOP
              LDR 3,2,11            ; ---- Stage 3: read single target number (count = 1) ----
              AIR 3,1
              LDR 0,0,20
              AIR 0,20
              STR 0,0,21
              OUT 0,1
              IN  0,0
              LDX 1,21
              LDR 3,1,0
              STR 3,2,13              ; Mirror TARGET into X2 scratch so we can use small offsets in the loop TARGETX := R3  (at X2+13)
              LDR 0,0,20              ; Reset pointer and seed from first element at base 0300 R0 := 0300
              STR 0,0,23              ; [0023] := 0300
              LDR 3,2,11              ; R3 := 0 (ZERO via X2+11). Next lines set up scan loop code base 'page'
              AIR 3,1                 ; R3 := 1
              SRC 3,6,L,L             ; R3 := 0100₈
              STR 3,0,26              ; [0026] := 0100₈   ; choose any free low cell
              LDX 3,26                ; IX3 := 0100₈
              AIR 1,20                ; R1 := 20 total elements
              LDX 1,23                ;  ---- Seed DIFFMIN and BESTVAL from first element ---- X1 := [0023]
              LDR 2,1,0               ; R2 := M[X1] (first value)
              STR 2,2,14              ; CURVALX := R2
              SMR 2,2,13              ; R2 := |CURVALX - TARGETX| R2 := R2 - M[TARGETX]
              JGE 2,3,INIT_OK
              LDR 0,2,13              ; R0 := TARGETX
              SMR 0,2,14              ; R0 := target - value
              STR 0,2,15              ; DIFFABSX := |diff|
              LDR 2,2,15              ; R2 := |diff|
INIT_OK:      STR 2,2,16              ; DIFFMINX := |diff(first)|
              LDR 3,2,14              ; R3 := first value
              STR 3,2,17              ; BESTVALX := first value
              LDR 0,0,23              ; advance ptr; set remaining count to 19 R0 := ptr
              AIR 0,1                 ; R0++
              STR 0,0,23              ; [0023] := ptr+1
              LDR 1,2,11              ; R1 := 0. we have to zero so that AIR can set to 19 for remaining loop iters on the next line
              AIR 1,19                ; R1 := 19
SCAN_LOOP:    LDX   1,23             ; X1 := [0023]
              LDR   2,1,0            ; R2 := M[X1]        (current value)
              STR   2,2,14           ; CURVALX := R2
              SMR   2,2,13           ; R2 := CURVALX - TARGETX
              JGE   2,3,HAVE_ABS     ; if >=0, R2 already holds |diff|
              LDR   0,2,13           ; R0 := TARGETX
              SMR   0,2,14           ; R0 := TARGETX - CURVALX
              STR   0,2,15           ; DIFFABSX := |diff|
              LDR   2,2,15           ; R2 := |diff|
HAVE_ABS:     STR   2,2,15           ; DIFFABSX := |diff| (also for diff >= 0)**   
              LDR   0,2,16            ; R0 := DIFFMINX
              SMR   0,2,15            ; R0 := DIFFMINX - |diff|
              JGE   0,3,TAKE_NEW_MIN  ; test R0 (the compare result)
              JMA   3,STEP_PTR
TAKE_NEW_MIN: STR   2,2,16            ; DIFFMINX := |diff|
              LDR   3,2,14            ; R3 := CURVALX
              STR   3,2,17            ; BESTVALX := R3
STEP_PTR:     LDR   0,0,23           ; R0 := ptr; Move pointer forward by 1 and loop back
              AIR   0,1              ; R0 := ptr + 1
              STR   0,0,23           ; [0023] := ptr+1
              SOB   1,3,SCAN_LOOP    ; SOB decrements R1 and branches back to SCAN_LOOP while R1 > 0. When R1 becomes 0, it falls through to SCAN_DONE.
SCAN_DONE:    LDR 0,2,17      ; R0 := BESTVALX
              LDR 1,2,16      ; R1 := DIFFMINX
              OUT 0,3         ; print best value
              OUT 1,3         ; print min diff
              HLT
POOL_BASE:    DATA 0        ; +0 (anchor; value unused)
PAD1:         DATA 0        ; +1
PAD2:         DATA 0        ; +2
PAD3:         DATA 0        ; +3
PAD4:         DATA 0        ; +4
PAD5:         DATA 0        ; +5
PAD6:         DATA 0        ; +6
PAD7:         DATA 0        ; +7
PAD8:         DATA 0        ; +8
PAD9:         DATA 0        ; +9
PAD10:        DATA 0        ; +10
ZERO:         DATA 0        ; +11  <-- used by LDR *,2,11
ONE:          DATA 1        ; +12
COUNT20:      DATA 20       ; +13
NEG1:         DATA -1       ; +14
TARGETX:      DATA 0        ; +15 ; X2-based scratch (use offsets in code if needed)
CURVALX:      DATA 0        ; +16
DIFFABSX:     DATA 0        ; +17
DIFFMINX:     DATA 0        ; +18
BESTVALX:     DATA 0        ; +19
TARGET:       DATA 0        ; globals (kept for compatibility)
WORKPTR:      DATA 0
DIFFABS:      DATA 0
DIFFMIN:      DATA 0
CURVAL:       DATA 0
BESTVAL:      DATA 0